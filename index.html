<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Breakout Reveal – 1 Stage</title>
  <style>
    :root{ --fg:#eaf2ff; --muted:#a6b3c6; --accent:#79d3ff; --danger:#ff6a7a; --bg0:#0b0e14; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:#0b0e14;color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",Hiragino Kaku Gothic ProN,Meiryo}
    canvas{display:block;width:100vw;height:100vh;touch-action:none;-webkit-tap-highlight-color:transparent}

    /* HUD */
    #hud{position:fixed;inset:10px auto auto 10px;display:flex;gap:10px;z-index:5}
    .chip{backdrop-filter:blur(8px);background:rgba(255,255,255,.07);border:1px solid rgba(255,255,255,.12);padding:8px 10px;border-radius:12px}
    #pauseBtn,#startBtn,#againBtn{cursor:pointer;border:none;padding:10px 14px;border-radius:12px;background:rgba(255,255,255,.1);color:var(--fg)}

    .overlay{position:fixed;inset:0;display:grid;place-items:center;z-index:10;padding:24px}
    .panel{width:min(640px,92vw);text-align:center;border-radius:18px;padding:22px;background:linear-gradient(180deg,rgba(255,255,255,.10),rgba(255,255,255,.06));border:1px solid rgba(255,255,255,.14)}
    h1{margin:0 0 6px}
    p{margin:.3em 0;color:var(--muted)}
    .hidden{display:none!important}
    .kbd kbd{background:rgba(0,0,0,.35);padding:4px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.15)}
  </style>
</head>
<body>
  <canvas id="game" aria-label="Breakout game canvas"></canvas>
  <div id="hud">
    <div class="chip">SCORE <b id="score">0</b> ｜ LIVES <b id="lives">3</b></div>
  </div>

  <div id="start" class="overlay">
    <div class="panel">
      <h1>Breakout Reveal <small style="font-size:60%;opacity:.7">build r3</small></h1>
      <p>前面画像を“ブロック”として壊すと、背面の画像が現れます（1ステージ）。</p>
      <p class="kbd">操作：マウス/タッチでパドル移動、<kbd>スペース</kbd>でボール発射</p>
      <p style="margin-top:10px">画像ファイルを用意してください：<br><b>assets/front.jpg</b>（前面） と <b>assets/back.jpg</b>（背面）<br>※同じ比率推奨。PNGでも可（名前だけ合わせればOK）。</p>
      <button id="startBtn">スタート</button>
    </div>
  </div>

  <div id="over" class="overlay hidden">
    <div class="panel">
      <h1 id="overTitle">Game Over</h1>
      <p>Score: <b id="finalScore">0</b></p>
      <button id="againBtn">もう一度</button>
    </div>
  </div>

  <script>
  (function(){
    'use strict';

    // ====== Config ======
    const IMG_FRONT_CANDIDATES = [
      'assets/front.jpg','front.jpg','assets/front.png','front.png',
      'images/front.png','images/front.jpg',
      '../assets/front.png','../assets/front.jpg',
      '/block/assets/front.png','/block/assets/front.jpg','/block/front.png','/block/front.jpg'
    ];
    const IMG_BACK_CANDIDATES  = [
      'assets/back.jpg','back.jpg','assets/back.png','back.png',
      'images/back.png','images/back.jpg',
      '../assets/back.png','../assets/back.jpg',
      '/block/assets/back.png','/block/assets/back.jpg','/block/back.png','/block/back.jpg'
    ];

    const ROWS = 8, COLS = 14;      // ブロック数
    const BRICK_MARGIN = 0;         // 各ブロック間の隙間（見た目には使わず、当たり判定/破壊領域として）
    const PADDLE_W = 120, PADDLE_H = 16;
    const BALL_R = 7;
    const SPEED_BASE = 340;         // 初速
    const SPEED_GAIN = 1.015;       // 破壊時にわずかに加速
    const LIVES_INIT = 3;

    // ====== DOM ======
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const startOv = document.getElementById('start');
    const overOv = document.getElementById('over');
    const startBtn = document.getElementById('startBtn');
    const againBtn = document.getElementById('againBtn');
    const overTitle = document.getElementById('overTitle');
    const finalScoreEl = document.getElementById('finalScore');

    // ====== Canvas sizing ======
    let dpr=1, W=0, H=0; // CSSピクセル基準
    function resize(){
      dpr = window.devicePixelRatio || 1;
      const cssW = Math.max(360, window.innerWidth);
      const cssH = Math.max(520, window.innerHeight);
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // 描画はCSSピクセル基準
      W = cssW; H = cssH;
      computeLayout();
      // 画像のカバーフィットを更新
      if(frontImg.complete && backImg.complete){
        buildFrontMosaic();
      }
    }
    window.addEventListener('resize', resize);

    // ====== Image loading ======
    function loadImageFromList(list){
      return new Promise((resolve)=>{
        let i=0; const img = new Image();
        img.onload = ()=> resolve(img);
        function tryNext(){
          if(i>=list.length){ resolve(img); return; }
          img.src = list[i++]+`?v=${Date.now()}`; // cache-bust for GH Pages updates
        }
        img.onerror = tryNext; tryNext();
      });
    }
    let frontImg = new Image(), backImg = new Image();

    // ====== Helpers ======
    function drawCover(destCtx, img, dx, dy, dw, dh){
      if(!img || !img.width || !img.height){
        // placeholder grid
        destCtx.fillStyle = '#10141d'; destCtx.fillRect(dx,dy,dw,dh);
        destCtx.fillStyle = '#1b2230';
        for(let y=0;y<dh;y+=24){ destCtx.fillRect(dx, dy+y, dw, 1); }
        for(let x=0;x<dw;x+=24){ destCtx.fillRect(dx+x, dy, 1, dh); }
        destCtx.fillStyle = '#556'; destCtx.fillText('画像が見つかりません: assets/front.jpg / assets/back.jpg', dx+12, dy+24);
        return {sx:0,sy:0,sw:img.width||dw,sh:img.height||dh, x:dx, y:dy, w:dw, h:dh};
      }
      const sw = img.width, sh = img.height;
      const scale = Math.max(dw/sw, dh/sh);
      const w = sw*scale, h = sh*scale;
      const x = dx + (dw - w)/2; const y = dy + (dh - h)/2;
      destCtx.drawImage(img, x, y, w, h);
      return {x, y, w, h, scale};
    }

    // 乱択ヘルパー
    const choice = arr => arr[(Math.random()*arr.length)|0];

    // front画像をキャンバスと同サイズに“カバー描画”したモザイクとして保持
    let mosaicCanvas = document.createElement('canvas');
    let mosaicCtx = mosaicCanvas.getContext('2d');
    function buildFrontMosaic(){
      // front画像を「ブロック配置グリッドの範囲」にフィットさせる
      mosaicCanvas.width = Math.floor(grid.w * dpr);
      mosaicCanvas.height = Math.floor(grid.h * dpr);
      mosaicCtx.setTransform(dpr,0,0,dpr,0,0);
      mosaicCtx.clearRect(0,0,grid.w,grid.h);
      drawCover(mosaicCtx, frontImg, 0,0,grid.w,grid.h);
    }

    // ====== Level layout ======
    const bricks = []; // {x,y,w,h, alive}
    let bricksAlive = 0;
    let grid = {x:0,y:0,w:0,h:0,bw:0,bh:0};
    function computeLayout(){
      const marginSide = 24, marginTop = 80;
      const areaW = W - marginSide*2;
      const areaH = Math.min(H*0.45, 340);
      const bw = (areaW - (COLS-1)*BRICK_MARGIN) / COLS;
      const bh = (areaH - (ROWS-1)*BRICK_MARGIN) / ROWS;
      grid = {x: (W-areaW)/2, y: marginTop, w: areaW, h: areaH, bw, bh};
      if(bricks.length===0){
        for(let r=0;r<ROWS;r++){
          for(let c=0;c<COLS;c++){
            bricks.push({x:0,y:0,w:bw,h:bh,alive:true});
          }
        }
      }
      // 位置を更新
      let i=0;
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const x = grid.x + c*(bw+BRICK_MARGIN);
          const y = grid.y + r*(bh+BRICK_MARGIN);
          bricks[i].x=x; bricks[i].y=y; bricks[i].w=bw; bricks[i].h=bh; i++;
        }
      }
    }

    // ====== Game state ======
    const paddle = {x:0,y:0,w:PADDLE_W,h:PADDLE_H};
    const ball = {x:0,y:0,vx:0,vy:0,r:BALL_R, stuck:true, speed:SPEED_BASE};
    let score = 0, lives = LIVES_INIT;
    let running = false;
    let t = 0; // game time (s)
    let items = []; // falling power-ups
    const ITEM_DROP_CHANCE = 0.25, ITEM_SPEED = 180; // 25%で落ちる
    let expandUntil = 0, slowUntil = 0;

    function resetGame(){
      score = 0; lives = LIVES_INIT; scoreEl.textContent=score; livesEl.textContent=lives;
      for(const b of bricks){ b.alive=true; }
      bricksAlive = bricks.length;
      items.length = 0; expandUntil = 0; slowUntil = 0; t = 0;
      paddle.w = PADDLE_W;
      ball.speed = SPEED_BASE; placePaddle(); placeBallOnPaddle();
    }
      bricksAlive = bricks.length;
      ball.speed = SPEED_BASE; placePaddle(); placeBallOnPaddle();
    }

    function placePaddle(){
      paddle.w = PADDLE_W; paddle.h=PADDLE_H; paddle.x = (W - paddle.w)/2; paddle.y = Math.min(H-60, grid.y + grid.h + 80);
    }
    function placeBallOnPaddle(){ ball.stuck=true; ball.x = paddle.x + paddle.w/2; ball.y = paddle.y - ball.r - 1; ball.vx=0; ball.vy=0; }

    function launchBall(){ if(!ball.stuck) return; ball.stuck=false; const ang = -Math.PI*0.4 + (Math.random()*0.2-0.1); ball.vx = Math.cos(ang)*ball.speed; ball.vy = Math.sin(ang)*ball.speed; }

    // ====== Input ======
    function setPaddleByPointer(ev){ const rect = canvas.getBoundingClientRect(); const px = (ev.clientX - rect.left); paddle.x = Math.max(8, Math.min(W - paddle.w - 8, px - paddle.w/2)); if(ball.stuck) { ball.x = paddle.x + paddle.w/2; ball.y = paddle.y - ball.r - 1; } }
    canvas.addEventListener('pointerdown', (e)=>{ setPaddleByPointer(e); if(running) launchBall(); });
    canvas.addEventListener('pointermove', (e)=>{ if(e.pressure>0 || e.buttons>0) setPaddleByPointer(e); else setPaddleByPointer(e); });
    window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ e.preventDefault(); if(running) launchBall(); }});

    // ====== Physics ======
    function step(dt){
      if(ball.stuck) return;
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // 壁反射
      if(ball.x - ball.r < 0){ ball.x = ball.r; ball.vx = Math.abs(ball.vx); }
      if(ball.x + ball.r > W){ ball.x = W - ball.r; ball.vx = -Math.abs(ball.vx); }
      if(ball.y - ball.r < 0){ ball.y = ball.r; ball.vy = Math.abs(ball.vy); }

      // パドル衝突
      if(circleRectOverlap(ball.x,ball.y,ball.r, paddle.x,paddle.y,paddle.w,paddle.h) && ball.vy>0){
        const tHit = ((ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2)); // -1..1
        const ang = (-75 * Math.PI/180) * (1 - tHit)/2 + (75 * Math.PI/180) * (1 + tHit)/2;
        const sp = Math.min(820, Math.hypot(ball.vx, ball.vy) * 1.02);
        ball.vx = sp * Math.sin(ang);
        ball.vy = -sp * Math.cos(ang);
        ball.y = paddle.y - ball.r - 0.1;
      }

      // ブロック衝突
      for(let i=0;i<bricks.length;i++){
        const b = bricks[i]; if(!b.alive) continue;
        if(circleRectOverlap(ball.x,ball.y,ball.r, b.x,b.y,b.w,b.h)){
          b.alive = false; bricksAlive--; score += 10; scoreEl.textContent = score; ball.speed *= SPEED_GAIN;
          if(Math.random() < ITEM_DROP_CHANCE){
            const type = choice(['expand','slow','life']);
            items.push({x: b.x + b.w/2 - 14, y: b.y + b.h/2 - 10, w:28, h:20, vy:ITEM_SPEED, type});
          }
          const prevX = ball.x - ball.vx*dt, prevY = ball.y - ball.vy*dt;
          const fromLeft = prevX < b.x, fromRight = prevX > b.x + b.w, fromTop = prevY < b.y, fromBottom = prevY > b.y + b.h;
          if((fromLeft && !fromTop && !fromBottom) || (fromRight && !fromTop && !fromBottom)) ball.vx *= -1; else ball.vy *= -1;
          break;
        }
      }

      // アイテム落下＆取得
      for(let i=items.length-1;i>=0;i--){
        const it = items[i]; it.y += it.vy*dt;
        if(rectsOverlap(it.x,it.y,it.w,it.h, paddle.x,paddle.y,paddle.w,paddle.h)){
          applyItem(it); items.splice(i,1); continue;
        }
        if(it.y > H + 40){ items.splice(i,1); }
      }

      // 落下
      if(ball.y - ball.r > H){
        lives--; livesEl.textContent = lives; if(lives<=0){ end(false); } else { placePaddle(); placeBallOnPaddle(); }
      }

      // クリア
      if(bricksAlive<=0){ end(true); }
    }
      if(bricksAlive<=0){ end(true); }
    }

    function circleRectOverlap(cx,cy,r, rx,ry,rw,rh){
      const nx = Math.max(rx, Math.min(cx, rx+rw));
      const ny = Math.max(ry, Math.min(cy, ry+rh));
      const dx = cx - nx, dy = cy - ny; return (dx*dx + dy*dy) <= r*r;
    }
    function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }
    function applyItem(it){
      if(it.type==='expand'){
        expandUntil = Math.max(expandUntil, t) + 8; // 8秒
        paddle.w = PADDLE_W + 80;
      } else if(it.type==='slow'){
        slowUntil = Math.max(slowUntil, t) + 6; // 6秒
        ball.vx *= 0.75; ball.vy *= 0.75;
      } else if(it.type==='life'){
        lives++; livesEl.textContent=lives;
      }
    }

    // ====== Render ======
    function render(){
      // 背面画像（ブロックグリッドの範囲にのみ描画）
      drawCover(ctx, backImg, grid.x, grid.y, grid.w, grid.h);

      // 前面画像：生きているブロックの形にクリップして、その中だけ描画
      if(mosaicCanvas.width>0){
        ctx.save();
        ctx.beginPath();
        for(const b of bricks){ if(b.alive){ ctx.rect(b.x, b.y, b.w, b.h); } }
        ctx.clip();
        ctx.drawImage(mosaicCanvas, grid.x, grid.y);
        ctx.restore();
      } else {
        // 画像未読込の間のプレースホルダ
        ctx.save();
        ctx.beginPath();
        for(const b of bricks){ if(b.alive){ ctx.rect(b.x, b.y, b.w, b.h); } }
        ctx.clip();
        drawCover(ctx, frontImg, grid.x, grid.y, grid.w, grid.h);
        ctx.restore();
      }

      // パワーアップアイテム
      for(const it of items){
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = it.type==='expand' ? '#79d3ff' : (it.type==='slow' ? '#ffe066' : '#7cff7a');
        ctx.fillRect(it.x, it.y, it.w, it.h);
        ctx.fillStyle = '#0b0e14';
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(it.type==='expand'?'E':(it.type==='slow'?'S':'+1'), it.x+it.w/2, it.y+it.h/2);
        ctx.restore();
      }

      // パドル
      ctx.fillStyle = 'rgba(255,255,255,.9)';
      ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

      // ボール
      ctx.beginPath(); ctx.fillStyle='#fff'; ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();
    } else {
        drawCover(ctx, frontImg, 0,0, W, H);
      }

      // パドル
      ctx.fillStyle = 'rgba(255,255,255,.9)';
      ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

      // ボール
      ctx.beginPath(); ctx.fillStyle='#fff'; ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();
    }

    // ====== Loop ======
    let last=performance.now();
    function frame(now){
      const dt = Math.min(0.033, (now-last)/1000); last=now;
      if(running){ t += dt; step(dt); updateEffects(); }
      render();
      requestAnimationFrame(frame);
    }

    function updateEffects(){
      if(expandUntil>0 && t>expandUntil && paddle.w!==PADDLE_W){ paddle.w = PADDLE_W; }
      // slow は徐々に速度が戻る想定のため明示的な解除処理は行わない
    }

    // ====== Game flow ======
    function start(){ hide(startOv); hide(overOv); running=true; resetGame(); }
    function end(cleared){ running=false; finalScoreEl.textContent=score; overTitle.textContent = cleared? 'Stage Clear!' : 'Game Over'; show(overOv); }

    function show(el){ el.classList.remove('hidden'); }
    function hide(el){ el.classList.add('hidden'); }

    startBtn.addEventListener('click', start);
    againBtn.addEventListener('click', start);

    // ====== Init ======
    Promise.all([
      loadImageFromList(IMG_FRONT_CANDIDATES).then(img=>{frontImg=img;}),
      loadImageFromList(IMG_BACK_CANDIDATES).then(img=>{backImg=img;})
    ]).then(()=>{
      resize();
      buildFrontMosaic();
      resetGame();
      requestAnimationFrame(frame);
    });

    window.addEventListener('resize', ()=>{ placePaddle(); if(ball.stuck) placeBallOnPaddle(); });

  })();
  </script>
</body>
</html>
